<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerical Method · HOODESolver.jl</title><meta name="title" content="Numerical Method · HOODESolver.jl"/><meta property="og:title" content="Numerical Method · HOODESolver.jl"/><meta property="twitter:title" content="Numerical Method · HOODESolver.jl"/><meta name="description" content="Documentation for HOODESolver.jl."/><meta property="og:description" content="Documentation for HOODESolver.jl."/><meta property="twitter:description" content="Documentation for HOODESolver.jl."/><meta property="og:url" content="https://pnavaro.github.io/HOODESolver.jl/numerical_method/"/><meta property="twitter:url" content="https://pnavaro.github.io/HOODESolver.jl/numerical_method/"/><link rel="canonical" href="https://pnavaro.github.io/HOODESolver.jl/numerical_method/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="HOODESolver.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">HOODESolver.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Documentation</a></li><li class="is-active"><a class="tocitem" href>Numerical Method</a><ul class="internal"><li><a class="tocitem" href="#Two-scale-formulation"><span>Two-scale formulation</span></a></li><li><a class="tocitem" href="#Discretization"><span>Discretization</span></a></li><li><a class="tocitem" href="#Non-homogeneous-case-f(t,-u)"><span>Non-homogeneous case <span>$f(t, u)$</span></span></a></li></ul></li><li><a class="tocitem" href="../common_interface/">OrdinaryDiffEq</a></li><li><a class="tocitem" href="../quickstart/">Quickstart</a></li><li><a class="tocitem" href="../charged_particle/">Charged Particle</a></li><li><a class="tocitem" href="../future_work/">Future work</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Numerical Method</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Numerical Method</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/pnavaro/HOODESolver.jl/blob/{commit}{path}#{line}" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/pnavaro/HOODESolver.jl/blob/master/docs/src/numerical_method.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Numerical-method"><a class="docs-heading-anchor" href="#Numerical-method">Numerical method</a><a id="Numerical-method-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-method" title="Permalink"></a></h1><h2 id="Two-scale-formulation"><a class="docs-heading-anchor" href="#Two-scale-formulation">Two-scale formulation</a><a id="Two-scale-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Two-scale-formulation" title="Permalink"></a></h2><p>First, rewrite equation (1) using the variable change <span>$w(t)=\exp(-(t-t_{start})A/\varepsilon) u(t)$</span> to obtain</p><p class="math-container">\[\frac{d w(t)}{dt} = F\Big(\frac{t-t_{start}}{\varepsilon}, w(t) \Big), \;\;\; w(t_{start})=u_{in}, \;\; \varepsilon\in ]0, 1],\]</p><p>where the function <span>$F$</span> is expressed from the data of the original problem (1)</p><p class="math-container">\[F\Big( \frac{s}{\varepsilon}, w \Big) = \exp(-sA/\varepsilon) \; f( \exp(sA/\varepsilon), \; w).\]</p><p>We then introduce the function <span>$U(t, \tau), \tau\in [0, 2 \pi]$</span> such that <span>$U(t, \tau=(t-t_{start})/\varepsilon) = w(t)$</span>. The two-scale function is then the solution of the following equation</p><p class="math-container">\[\frac{\partial U}{\partial t} + \frac{1}{\varepsilon} \frac{\partial U}{\partial \tau} =  F( \tau, U), \;\;\; U(t=t_{start}, \tau)=\Phi(\tau), \;\; \varepsilon\in ]0, 1], \;\;\;\;\;\;\;\;\;\; (2)\]</p><p>where <span>$\Phi$</span> is a function checking <span>$\Phi(\tau=0)=u_{0}$</span> chosen so that the <span>$U$</span> solution of (2) is smooth (see [<a href="../#Chartier2015">2</a>] and [<a href="../#Chartier2020">1</a>].</p><h2 id="Discretization"><a class="docs-heading-anchor" href="#Discretization">Discretization</a><a id="Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization" title="Permalink"></a></h2><p>The numerical method is based on a discretization of equation (2). In the direction <span>$\tau$</span>, a spectral method is used, while for the time <span>$t$</span>, an exponential Adams-Bashforth method allows to build a high order method (see [<a href="../#Chartier2020">1</a>]). The initialization is based on a &quot;butterfly&quot; technique (going back and forth around the initial time).</p><h3 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h3><p>Let r be the order of the method <span>$AB_r$</span>.<br/>Let <span>$\Delta t$</span> the time step, for <span>$i \in \{r, -(r-1), \ldots, r-1, r\}$</span>, we note <span>$u_i = u(t_{start}+i \Delta t)$</span>.<br/>Let <span>$r&#39;$</span> be the orders of the intermediate AB methods we will use.<br/>If <span>$u_{k}$</span> is known with a precision of <span>${\mathcal O}(\Delta t^{r&#39;+1})$</span>, and for <span>$r&#39; \geq 2, u_{k-1}, \ldots, u_{k-r&#39;+1}$</span> are known with a precision of <span>${\mathcal O}(\Delta t^{r&#39;})$</span> then we can calculate <span>$u_{k+1}$</span> with a precision of <span>${\mathcal O}(\Delta t^{r&#39;+1})$</span> with the method <span>$AB_{r&#39;}$</span>.<br/>Similarly, if <span>$u_{k}$</span> is known with a precision of <span>${\mathcal O}(\Delta t^{r&#39;+1})$</span>, and for <span>$r&#39; \geq 2, u_{k+1}, \ldots, u_{k+r&#39;-1}$</span> are known with a precision of <span>${\mathcal O}(\Delta t^{r&#39;})$</span> then we can calculate <span>$u_{k-1}$</span> with a precision of <span>${\mathcal O}(\Delta t^{r&#39;+1})$</span> with the method <span>$AB_{r&#39;}$</span>.</p><h3 id="Algorithm"><a class="docs-heading-anchor" href="#Algorithm">Algorithm</a><a id="Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm" title="Permalink"></a></h3><ul><li>With the method <span>$AB_1$</span>, from <span>$u_0$</span> we calculate <span>$u_{-1}$</span> with a precision of <span>${\mathcal O}(\Delta t^2)$</span></li><li>With the method <span>$AB_2$</span>, starting from <span>$u_{0}$</span> and <span>$u_{-1}$</span>, we calculate <span>$u_{1}$</span> with a precision of <span>${\mathcal O}(\Delta t^3)$</span></li><li>For <span>$r&#39; = $3 to $r&#39; = r$</span>.<ul><li>For <span>$k=1$</span> to <span>$k=r&#39;-1$</span><ul><li>With the method <span>$AB_{r&#39;-1}$</span>, from <span>$u_{1-k}, u_{2-k}, \ldots,u_{r&#39;-1-k}$</span>, we calculate <span>$u_{-k}$</span> with a precision of <span>${\mathcal O}(\Delta t^{r&#39;})$</span></li></ul></li><li>For <span>$k=1$</span> to <span>$k=r&#39;-1$</span><ul><li>With the method <span>$AB_{r&#39;}$</span>, from <span>$u_{k-1}, u_{k-2}, \ldots,u_{k-r&#39;}$</span>, we calculate <span>$u_{k}$</span> with a precision of <span>${\mathcal O}(\Delta t^{r&#39;+1})$</span></li></ul></li></ul></li></ul><p>At the end of this algorithm, the values <span>$u_0, u_1, \ldots u_{r-1}$</span> are known with a precision of <span>${\mathcal O}(\Delta t^{r+1})$</span>, we can launch the algorithm <span>$AB_r$</span>. Note that this technique requires that the function <span>$f$</span> has to be smooth enough (namely <span>$f\in {\mathcal C}^r([t_{start} - r \Delta t, t_{end}])$</span>).  </p><h3 id="The-Adams-Bashforth-Method"><a class="docs-heading-anchor" href="#The-Adams-Bashforth-Method">The Adams-Bashforth Method</a><a id="The-Adams-Bashforth-Method-1"></a><a class="docs-heading-anchor-permalink" href="#The-Adams-Bashforth-Method" title="Permalink"></a></h3><p>For an Adams-Bashforth method of order <span>$r$</span> in time and spectral <span>$\tau$</span>, we first introduce a mesh in the <span>$\tau$</span> direction.<br/><span>$\tau_{\ell} = \ell \Delta \tau, \ell = 0, \ldots, N_{\tau}-1$</span>. Where <span>$N_{\tau}$</span> is the number of points of discretization. If we apply the Fourier transform to the two-scale equation, we obtain </p><p class="math-container">\[\frac{\partial \hat{U}_\ell}{\partial t} + \frac{i\ell}{\varepsilon}\hat{U}_\ell = \hat{F}_\ell(t), \;\; \ell=-N_\tau/2, \dots, N_\tau/2-1,\]</p><p>with</p><p class="math-container">\[U(t, \tau_k) = \sum_{\ell=-N_{\tau}/2}^{N_{\tau}/2-1} \hat{U}_{\ell}(t) e^{i\ell k 2\pi/N_{\tau}} \;\;\; \text{ and } F(\tau_k, U(t, \tau_k)) = \sum_{\ell=-N_{\tau}/2}^{N_{\tau}/2-1} \hat{F}_{\ell}(t) e^{i\ell k 2\pi/N_\tau}.\]</p><p>and the inverse (discrete) Fourier transform formulae</p><p class="math-container">\[\hat{U}_{\ell}(t) = \frac{1}{N_{\tau}}\sum_{k=0}^{N_{\tau}-1} U(t, \tau_k) e^{-i\ell k 2\pi/N_{\tau}}\;\;\; \text{ and } \hat{F}_{\ell}(t) = \frac{1}{N_{\tau}}\sum_{k=0}^{N_{\tau}-1} F(\tau_k, U(t, \tau_k))e^{-i\ell k 2\pi/N_{\tau}}.\]</p><p>If we wish to calculate <span>$\hat{F}_{\ell}$</span> from <span>$\hat{U}_{\ell}$</span> we have the following formula </p><p class="math-container">\[F(\tau_k,U(t, \tau_k)) = e^{-\tau_k A}f(e^{\tau_k A}U(t, \tau_k)) \;\;\]</p><p>from which the Fourier transform is calculated in <span>$\tau$</span> from the discrete Fourier transform formulas above.</p><p>Now, given a time step <span>$\Delta t&gt;0$</span> and a discretization in time <span>$t_n=n\Delta t$</span>, we can write the following Duhamel formula (<span>$n\geq 0$</span>)</p><p class="math-container">\[\hat{U}_{\ell}(t_{n+1}) 
= e^{-i\ell\Delta t/\varepsilon}\hat{U}_{\ell}(t_{n})  + \int_0^{\Delta t} e^{-i\ell(\Delta t -s)/\varepsilon} \hat{F}_\ell(t_n+s)ds.\]</p><p>Thus, to obtain a <span>$(r+1)$</span> scheme, we can  approaches the function <span>$\hat{F}_\ell(t_n+s)$</span> by the Lagrange polynomial of order <span>$r$</span> interpolator at points <span>$t_{n-j}, j=0, \dots, r$</span>. This polynomial is written </p><p class="math-container">\[\hat{F}_\ell(t_n+s) \approx \sum_{k=0}^r \Big(\Pi_{j=0, j\neq k}^r \frac{s+j \Delta t}{(j-k)\Delta t} \Big) \hat{F}_\ell(t_n-t_j), \;\; n\geq 0.\]</p><p>Thus, from this approximation, we integrate exactly, which requires the following formulas</p><p class="math-container">\[p^{[r]}_{\ell, j} = \int_0^{\Delta t}e^{-i\ell(\Delta t -s)/\varepsilon}\Big( \Pi_{j=0, j\neq k}^r \frac{s+j \Delta t}{(j-k)\Delta t}\Big) ds,\]</p><p>for each <span>$j$</span> and <span>$\ell$</span> such that <span>$0\leq j\leq r, \; \ell=-N_\tau/2, \dots, N_\tau/2-1$</span>. These coefficients <span>$p^{[r]}_{\ell, j}$</span> can be pre-calculated and stored once and for all. Thus, the schema is finally written</p><p class="math-container">\[\hat{U}_{\ell}^{n+1}= e^{-i\ell\Delta t/\varepsilon}\hat{U}_{\ell}^n + \sum_{j=0}^r p^{[r]}_{\ell, j} \hat{F}_\ell^{n-j},\]</p><p>with <span>$\hat{U}_{\ell}^n \approx \hat{U}_{\ell}(t_n)$</span> and <span>$\hat{F}_\ell^{n-j}\approx \hat{F}_\ell(t_{n-j})$</span>. </p><p>We can verify that the truncation error in this schema is  <span>${\mathcal O}(\Delta t^{r+1})$</span>, once the initial values  <span>$\hat{U}_\ell^1, \dots, \hat{U}_\ell^r$</span> have been calculated.  </p><h2 id="Non-homogeneous-case-f(t,-u)"><a class="docs-heading-anchor" href="#Non-homogeneous-case-f(t,-u)">Non-homogeneous case <span>$f(t, u)$</span></a><a id="Non-homogeneous-case-f(t,-u)-1"></a><a class="docs-heading-anchor-permalink" href="#Non-homogeneous-case-f(t,-u)" title="Permalink"></a></h2><p>Here we consider the case where <span>$f$</span> depends on the variable <span>$t$</span>.</p><p class="math-container">\[\frac{d u(t)}{dt} = \frac{1}{\varepsilon} A u(t) + f(t, u(t)), \;\;\; u(t=t_{start})=u_{in}, \;\; \varepsilon\in ]0, 1] \;\;\;\; (3)\]</p><p>The non-homogeneous case (3) falls under (1), by entering the variable  <span>$\theta : t \in [t_{start}, t_{end}] \mapsto \theta(t) = t\in \mathbb{R}$</span>  which allows us to reformulate the non-homogeneous case (3) into a homogeneous problem of the form (1). Indeed, we rephrase (3) as follows</p><p class="math-container">\[\begin{aligned}
\frac{d u(t) }{dt}  &amp; = \frac{1}{\varepsilon} Au(t) + f(\theta(t), u(t)), \\
\frac{d \theta(t) }{dt}  &amp; = 1
\end{aligned}\;\;\;\;(4)\]</p><p>with the initial condition  <span>$u(t_{start})=u_{in}, \theta(t_{start})=t_{start}$</span>. Thus, the problem (4) is rewritten into an equation<br/>satisfied by <span>$y: t\in [t_{start}, t_{end}] \mapsto y(t) =(u(t), \theta(t))\in \mathbb{R}^{n+1}$</span></p><p class="math-container">\[\frac{d y}{dt} = \frac{1}{\varepsilon} \tilde{A} y + g(y), \;\; y(t_{start})=(u_{in}, t_{start}),\]</p><p>with <span>$\tilde{A}\in{\mathcal M}_{n+1, n+1}(\mathbb{R})$</span></p><p class="math-container">\[\tilde{A}=
\left(
\begin{array}{cccc}
   &amp;    &amp;     &amp; 0 \\
   &amp; A &amp;     &amp; 0 \\
   &amp;    &amp;    &amp; 0 \\
0 &amp; 0 &amp; 0 &amp;  0 
\end{array}
\right) \;\;\;\; \text{ and } \;\;\;\;
g(y)=g(u, \theta) = \left(
\begin{array}{cccccc}
f(\theta, u) \\
1
\end{array}
\right) \in \mathbb{R}^{n+1}.\]</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Documentation</a><a class="docs-footer-nextpage" href="../common_interface/">OrdinaryDiffEq »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 9 October 2024 15:54">Wednesday 9 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
