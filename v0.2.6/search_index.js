var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [HOODESolver]\nOrder   = [:function]","category":"page"},{"location":"functions/#CommonSolve.solve-Union{Tuple{HOODEProblem{T}}, Tuple{T}} where T<:AbstractFloat","page":"Functions","title":"CommonSolve.solve","text":"function solve(prob::HOODEProblem{T}; \nnb_tau::Integer=32, \norder::Integer=4, \norder_prep::Integer=order+2, \ndense::Bool=true, \nnb_t::Integer=100, \ngetprecision::Bool=dense,\nverbose=100,\npar_u0::Union{PrepareU0,Missing}=missing,\np_coef::Union{CoefExpAB,Missing}=missing\n) where T<:AbstractFloat\n\nspecific interface solver for Highly oscillatory problems, that an ODE of this form:\n\nfracdelta u(t)delta t = frac1varepsilon A + F(u(t) t)\n\nwhere u in R^n and  0  varepsilon  1 A must be a periodic matrix i.e. e^t A = e^(t+pi) A for any t in R\n\nArgument :\n\nprob::HOODEProblem{T} : The problem to solve\n\nKeywords :\n\nnb_tau::Integer=32 : number of values of FFT transform, must be power of twoscalespureab\norder::Integer=4 : order of Adams-Bashforth method, and also of the interpolatation\norder_prep::Integer=order+2 : order of the preparation\ndense::Bool=true : if true it is possible to compute solution at any time of the interval\nnb_t::Integer=100 : number of period slices\ngetprecision::Bool=dense : compute the absolute and relative precision\npar_u0::Union{PrepareU0,Missing}=missing : preparation data for u0\np_coef::Union{CoefExpAB,Missing}=missing : coefficients for Adams-Bashforth method\n\nExamples :\n\n\n\n\n\n","category":"method"},{"location":"functions/#CommonSolve.solve-Union{Tuple{ntau}, Tuple{order}, Tuple{ODEProblem, HOODEAB{order, ntau}}} where {order, ntau}","page":"Functions","title":"CommonSolve.solve","text":"solve(prob::ODEProblem, alg::HOODEAB{order, ntau}; \ndt=nothing,\nkwargs...\n) where {order,ntau}\n\ncommon interface solver for Highly oscillatory problems, that an ODE of this form\n\nfracdelta u(t)delta t = frac1varepsilon A + F(u(t) t)\n\nwhere u in R^n and  0  varepsilon  1 A must be a periodic matrix i.e. e^t A = e^(t+pi) A for any t in R\n\nArgument :\n\nprob::ODEProblem : The problem to solve\nalg::HOODEAB{order, ntau} : the Adams-Bashforth HOODE algorithm\n\nKeywords :\n\ndt : duration of a time interval\nkwargs... : other keywords\n\n\n\n\n\n","category":"method"},{"location":"functions/#HOODESolver.twoscales_pure_ab-Tuple{HOODESolver.PrepareTwoScalesPureAB}","page":"Functions","title":"HOODESolver.twoscales_pure_ab","text":"twoscales_pure_ab(par::PrepareTwoScalesPureAB; only_end::Bool=false, diff_fft::Bool=false, res_fft::Bool=false, verbose::Integer=100)\n\ncompute the data to get solution of the differential equation\n\nArguments :\n\npar::PrepareTwoScalesPureAB : contains all the parameters and prepared data\n\nKeywords :\n\nonly_end=false : if true return only the result for t_end\ndiff_fft::Bool=false : if true return data about diff\nres_fft::Bool=false : if true return u_caret data indispensable for interpolation\nverbose::Integer: level off traces (0 means no output)\n\n\n\n\n\n","category":"method"},{"location":"functions/#Polynomials.derivative-Tuple{HOODESolver.PolyExp}","page":"Functions","title":"Polynomials.derivative","text":"derivative(pe::PolyExp)\n\nConstruct the derivative of the pe function.\n\nExamples\n\njulia> derivative(PolyExp([1, 3, -1],3,1))\nPolyExp(Polynomial(6 + 7*x - 3*x^2)*exp(3*x + 1))\n\njulia> derivative(PolyExp([1.0+im, 3im, -1, 4.0], 2.0+1.5im,1.0im))\nPolyExp(Polynomial((0.5 + 6.5im) - (6.5 - 6.0im)*x + (10.0 - 1.5im)*x^2 + (8.0 + 6.0im)*x^3)*exp((2.0 + 1.5im)*x + 1.0im))\n\n\n\n\n\n","category":"method"},{"location":"functions/#Polynomials.integrate-Tuple{HOODESolver.PolyExp}","page":"Functions","title":"Polynomials.integrate","text":"integrate(pe::PolyExp)\n\nConstruct the integrate function of pe which is of PolyExp type. The algorithm used is a recursive integration by parts.\n\nExamples\n\njulia> integrate(PolyExp([1.0,2,3],2.0,5.0))\nPolyExp(Polynomial(0.75 - 0.5*x + 1.5*x^2)*exp(2.0*x + 5.0))\n\njulia> integrate(PolyExp([1.0+0im,2],2.0im,3.0+0im))\nPolyExp(Polynomial((0.5 - 0.5im) - 1.0im*x)*exp(2.0im*x + 3.0))\n\n\n\n\n\n","category":"method"},{"location":"charged_particle/#Charged-particle-Example","page":"Charged Particle","title":"Charged particle Example","text":"","category":"section"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"A system of charged particles under the effect of an external electro-magnetic field is considered to be  (E(t x) B(t x))in mathbbR^6.\nParticles are dynamically described by their position  x(t)inmathbbR^3 and their speed v(t)inmathbbR^3. We'll index by i the i-th component of a vector. Newton's equations applied to a particle can be written as","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"beginaligned\nfracd x(t) dt= v(t) \nfracd v(t) dt= fracem leftE(t x(t)) + v(t)times B(t x(t))right \nendaligned","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"We will assume that the magnetic field is written B(t x)=(0 0 1)^T and under a certain scaling, we consider the following equation","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"beginaligned\nfracd x_1(t) dt = frac1varepsilonv_1(t) \nfracd x_2(t) dt = frac1varepsilon v_2(t) \nfracd x_3(t) dt = v_3(t) \nfracd v_1(t) dt = E_1(t x(t)) + frac1varepsilonv_2(t)\nfracd v_2(t) dt = E_2(t x(t)) - frac1varepsilonv_1(t)\nfracd v_3(t) dt = E_3(t x(t)) \nendaligned","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"which is rewritten as follows","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"fracd u(t) dt= frac1varepsilonA u(t) + F(t u(t))","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"where the unknown vector u(t)=(x(t) v(t))inmathbbR^6, A is a square matrix of size 6times 6 and F is a function with a value in mathbbR^6. A and F are given by","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"A=\nleft(\nbeginarraycccccc\n0  0  0  1  0  0 \n0  0  0  0  1  0 \n0  0  0  0  0  0 \n0  0  0  0  1  0 \n0  0  0  -1  0  0 \n0  0  0  0  0  0 \nendarray\nright)  text and  \nF(t u(t)) = left(\nbeginarraycccccc\n0 \n0\nu_6(t)\nE_1(t u_1(t) u_2(t) u_3(t))\nE_2(t  u_1(t) u_2(t) u_3(t)\nE_3(t  u_1(t) u_2(t) u_3(t)\nendarray\nright)","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"We can consider the following E=(E_1 E_2 E_3) function","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"E(t x) =\nleft(\nbeginarrayccc\ncos(x_12)sin(x_2)sin(x_3)2\nsin(x_12)cos(x_2)sin(x_3)\nsin(x_12)sin(x_2)cos(x_3)\nendarray\nright)","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"using HOODESolver\nusing Plots","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"epsilon = 0.05\n\nA = [0 0 0  1 0 0; \n     0 0 0  0 1 0;\n     0 0 0  0 0 0; \n     0 0 0  0 1 0; \n     0 0 0 -1 0 0; \n     0 0 0  0 0 0]\n\nf1 = LinearHOODEOperator( epsilon, A)\n\nfunction f2(u, p, t)\n    s1, c1 = sincos(u[1]/2)\n    s2, c2 = sincos(u[2])\n    s3, c3 = sincos(u[3])\n    return [0, 0, u[6], c1*s2*s3/2, s1*c2*s3, s1*s2*c3]\nend\n\ntspan = (0.0, 1.0)\nu0 = [1.0, 1.5, -0.5, 0, -1.2, 0.8]\nprob = SplitODEProblem(f1, f2, u0, tspan)\nsol = solve(prob, HOODEAB() )\nplot(sol)","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"plot(sol,vars=(1,2,3))","category":"page"},{"location":"common_interface/#SplitODEProblem","page":"DifferentialEquations","title":"SplitODEProblem","text":"","category":"section"},{"location":"common_interface/","page":"DifferentialEquations","title":"DifferentialEquations","text":"The SplitODEProblem type from package DifferentialEquations.jl offers a interface for problems similar to the ones we are trying to solve.","category":"page"},{"location":"common_interface/","page":"DifferentialEquations","title":"DifferentialEquations","text":"Consider the Henon-Heiles system we can use one of the solvers dedicated to split problems, see Split ODE Solvers:","category":"page"},{"location":"common_interface/","page":"DifferentialEquations","title":"DifferentialEquations","text":"using Plots","category":"page"},{"location":"common_interface/","page":"DifferentialEquations","title":"DifferentialEquations","text":"using DifferentialEquations\n\nepsilon = 0.002\nA = [ 0 0 1 0 ;\n      0 0 0 0 ;\n     -1 0 0 0 ;\n      0 0 0 0 ]\n\nf1 = DiffEqArrayOperator( A ./ epsilon)\n\nfunction f2(du, u, p, t)\n    du[1] = 0\n    du[2] = u[4]\n    du[3] = 2*u[1]*u[2]\n    du[4] = -u[2] - u[1]^2 + u[2]^2 \nend\n\ntspan = (0.0, 0.1)\n\nu0 = [0.55, 0.12, 0.03, 0.89]\n\nprob1 = SplitODEProblem(f1, f2, u0, tspan);\nsol1 = solve(prob1, ETDRK4(), dt=0.001);\nnothing # hide","category":"page"},{"location":"common_interface/","page":"DifferentialEquations","title":"DifferentialEquations","text":"With our method we need to give the value of epsilon. In some case, you can get this value from f1. You can pass a DiffEqArrayOperator as argument to the problem but the method is not always valid  so we define a new type called LinearHOODEOperator:","category":"page"},{"location":"common_interface/","page":"DifferentialEquations","title":"DifferentialEquations","text":"using HOODESolver\n\nf1 = LinearHOODEOperator(epsilon, A)\nprob2 = SplitODEProblem(f1, f2, u0, tspan)\nsol2 = solve(prob2, HOODEAB(), dt=0.01)\n\nplot(sol1, vars=[3], label=\"EDTRK4\")\nplot!(sol2, vars=[3], label=\"HOODEAB\")\nplot!(sol2.t, getindex.(sol2.u, 3), m=:o)","category":"page"},{"location":"quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/#Hénon-Heiles-Example","page":"Quickstart","title":"Hénon-Heiles Example","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"We consider the system of Hénon-Heiles satisfied by u(t)=(u_1 u_2 u_3 u_4)(t).","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"fracd u dt = frac1varepsilon Au + f(u)  u(t_start)=u_inninmathbbR^4","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"where A and f are selected as follows","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"A=\nleft(\nbeginarraycccc\n0  0  1  0  \n0  0  0  0  \n-1  0  0  0  \n0  0  0  0  \nendarray\nright)  text and  \nf(u) = left(\nbeginarraycccc\n0 \nu_4\n-2 u_1 u_2\n-u_2-u_1^2+u_2^2\nendarray\nright)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"one chooses for example, varepsilon=0001 and u_in = (012 012 012 012)","category":"page"},{"location":"quickstart/#Input-parameters","page":"Quickstart","title":"Input parameters","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"The input arguments use the same format as the ODE package. ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Thus, first of all, we must define the arguments necessary to construct the problem (1), namely","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"the f function (in the form Julia) \nthe initial condition u_in.\nthe initial time t_start and final time t_end. \nthe second parameter of the \nthe A matrix \nvarepsilon in 0 1","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using HOODESolver, Plots\n\nepsilon= 0.0001\n\nA = [ 0 0 1 0 ; \n      0 0 0 0 ; \n     -1 0 0 0 ; \n      0 0 0 0 ]\n\nf1 = LinearHOODEOperator( epsilon, A)\n\nf2 = (u,p,t) ->  [ 0, u[4], 2*u[1]*u[2], -u[2] - u[1]^2 + u[2]^2 ] \n\ntspan = (0.0, 3.0)\n\nu0 = [0.55, 0.12, 0.03, 0.89]\n\nprob = SplitODEProblem(f1, f2, u0, tspan);\nnothing # hide","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"From the prob problem, we can now switch to its numerical resolution. ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"To do this, the numerical parameters are defined ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"the number of time slots N_t which defines the time step Delta t = fract_textend-t_startN_t but you can set the value of time step dt in the solve call.\nthe r order of the method \nthe number of N_tau points in the tau direction... \nthe order of preparation q of the initial condition ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"The default settings are : N_t=100, r=4, N_tau=32 and q=r+2=6 To solve the problem with the default parameters, just call the solve command with the problem already defined as parameter","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"sol = solve(prob, HOODEAB(), dt=0.1);\nnothing # hide","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Which is equivalent to HOODEAB( order=4, nb_tau=32 )","category":"page"},{"location":"quickstart/#Exhaustive-definition-of-the-parameters","page":"Quickstart","title":"Exhaustive definition of the parameters","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"prob : problem defined by SplitODEProblem \nnb_tau=32 : N_tau\norder=4 : order r of the method\norder_prep=order+2 : order of preparation of initial data\ndense=true : indicates whether or not to keep the data from the fourier transform, if dense=false, processing is faster but interpolation can no longer be done.\nnb_t=100 : N_t\ngetprecision=dense : indicates whether the accuracy is calculated, the method used to calculate the accuracy multiplies the processing time by 2.\nverbose=100 : trace level, if verbose=0 then nothing is displayed.\npar_u0 : If we have to make several calls to solve with the same initial data and in the same order, we can pass in parameter the already calculated data.\np_coef : table with the coefficients of the Adams-Bashforth method. This array can be used to optimize several calls with the same parameters.","category":"page"},{"location":"quickstart/#Exit-arguments","page":"Quickstart","title":"Exit arguments","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"As an output, a structure of type ODESolution from DifferentialEquations.jl. This structure can be seen as a function of t, it can also be seen as an array. Example:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"sol.prob\nsol.alg\nt=2.541451547\nsol(t)\nsol[end]\nsol(3.0)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"To view the result, you can also use Plot, for example","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"plot(sol) ","category":"page"},{"location":"quickstart/#Linear-non-homogeneous-case","page":"Quickstart","title":"Linear non-homogeneous case","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"The following non-homogeneous linear system is considered to be satisfied by u(t)=(u_1 u_2 u_3 u_4)(t)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"fracd u dt = frac1varepsilon Au + f(t u)  u(0)=u_ininmathbbR^4","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"where A and f are selected as follows","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"A=\nleft(\nbeginarraycccc\n0  0  1  0  \n0  0  0  0  \n-1  0  0  0  \n0  0  0  0  \nendarray\nright)  text and  \nf(t u) = Bu +alpha t +beta  text with   \nBin mathcal M_4 4(mathbbR) alpha beta in mathbbR^4","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"B alpha beta are chosen randomly.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"We wish to obtain a high precision, so we will use BigFloat real numbers, they are encoded on 256 bits by default which gives a precision bound of about 2^-256 approx 10^-77.  At the end, we compare a calculated result with an exact result. For this, you must use the dedicated HOODEProblem type:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using HOODESolver\nusing Plots\nusing Random","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"\nrng = MersenneTwister(1111)\n\nA=[0 0 1 0 ; 0 0 0 0 ; -1 0 0 0 ; 0 0 0 0]\nB = 2rand(rng, BigFloat, 4, 4) - ones(BigFloat, 4, 4)\nalpha = 2rand(rng, BigFloat, 4) - ones(BigFloat, 4)\nbeta = 2rand(rng, BigFloat, 4) - ones(BigFloat, 4)\nu0 = [big\"0.5\", big\"-0.123\", big\"0.8\", big\"0.7\"]\nt_start=big\"0.0\"\nt_end=big\"1.0\"\nepsilon=big\"0.017\"\n\nfct = (u,p,t)-> B*u + t*p[1] +p[2]\n\nprob = HOODEProblem(fct, u0, (t_start,t_end), (alpha, beta), A, epsilon, B)\n\nsol = solve(prob, nb_t=10000, order=8)\nsol.absprec","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"t=big\"0.9756534187771\"\nsol(t)-getexactsol(sol.par_u0.parphi, u0, t)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"plot(sol.t,sol.u_tr)","category":"page"},{"location":"quickstart/#Calculation-of-the-exact-solution","page":"Quickstart","title":"Calculation of the exact solution","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"This involves calculating the exact solution u(t) of the following equation at the instant t","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"fracd u dt = frac1varepsilon Au + Bu +alpha t +beta  u(t_start)=u_ininmathbbR^4text  A text and B text are defined above ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Let","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"beginaligned\n    M = frac1varepsilon A + B\n    C = e^-t_start Mu_in +M^-1 e^-t_start M (t_startalpha+beta)+ M^-2 e^-t_start M alpha\n    C_t = -M^-1 e^-t M (talpha+beta)-M^-2 e^-t M alpha\n    u(t) = e^t M ( C + C_t)\nendaligned","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Which, translated into Julia language, gives the code of the function getexactsol : ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"function getexactsol(par::PreparePhi, u0, t)\n    @assert !ismissing(par.matrix_B) \"The debug matrix is not defined\"\n    sparse_A = par.sparse_Ap[1:(end-1),1:(end-1)]\n    m = (1/par.epsilon)*sparse_A+par.matrix_B\n    t_start = par.t_0\n    if ismissing(par.paramfct)\n        return exp((t-t0)*m)*u0\n    end\n    a, b = par.paramfct\n    mm1 = m^(-1)\n    mm2 = mm1^2\n    e_t0 = exp(-t_start*m)\n    C = e_t0*u0 + mm1*e_t0*(t_start*a+b)+mm2*e_t0*a\n    e_inv = exp(-t*m)\n    e = exp(t*m)\n    C_t = -mm1*e_inv*(t*a+b)-mm2*e_inv*a\n    return e*C+e*C_t\nend","category":"page"},{"location":"quickstart/#Accuracy-of-the-result-according-to-the-time-interval","page":"Quickstart","title":"Accuracy of the result according to the time interval","text":"","category":"section"},{"location":"quickstart/#Linear-problem","page":"Quickstart","title":"Linear problem","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"From a problem of the previous type, as long as we can calculate the exact solution, it is possible to know exactly what the error is. The initialization data being","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using HOODESolver\n\nA = [0 0 1 0 ; 0 0 0 0 ; -1 0 0 0 ; 0 0 0 0]\n\nu0 = BigFloat.([-34//100, 78//100, 67//100, -56//10])\n\nB = BigFloat.([12//100 -78//100 91//100 34//100\n    -45//100 56//100 3//100 54//100\n    -67//100 09//100 18//100 89//100\n    -91//100 -56//100 11//100 -56//100])\n\nalpha =  BigFloat.([12//100, -98//100, 45//100, 26//100])\n\nbeta =  BigFloat.([-4//100, 48//100, 23//100, -87//100])\n\nepsilon = 0.015\n\nt_end = big\"1.0\"\n\nfct = (u,p,t)-> B*u + t*p[1] +p[2]\n\nprob = HOODEProblem(fct,u0, (big\"0.0\",t_end), (alpha, beta), A, epsilon, B)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Note that the floats are coded on 512 bits.\nBy varying Delta t from 10^-2 to 510^-6 (i.e. nb_t from 100 to 204800) on a logarithmic scale, for odd orders from 3 to 17 we get these errors","category":"page"},{"location":"quickstart/#Precision-of-the-result-with-ε-0.015","page":"Quickstart","title":"Precision of the result with ε = 0.015","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Now with the same initial data, order being setted to 6, and varepsilon = 015 0015 ldots 15times 10^-7.\nHere floats are coded on 256 bits.","category":"page"},{"location":"quickstart/#Precision-of-the-result-with-order-6","page":"Quickstart","title":"Precision of the result with order = 6","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"(Image: )","category":"page"},{"location":"quickstart/#Problem-with-Hénon-Heiles-function","page":"Quickstart","title":"Problem with Hénon-Heiles function","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"u0=BigFloat.([90, -44, 83, 13]//100)\nt_end = big\"1.0\"\nepsilon=big\"0.0017\"\nfct = u -> [0, u[4], -2u[1]*u[2], -u[2]-u[1]^2+u[2]^2]\nA = [0 0 1 0; 0 0 0 0;-1 0 0 0; 0 0 0 0]\nprob = HOODEProblem(fct, u0, (big\"0.0\",t_end), missing, A, epsilon)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"The float are coded on 512 bits.","category":"page"},{"location":"quickstart/#Precision-of-the-result-with-ε-0.0017","page":"Quickstart","title":"Precision of the result with ε = 0.0017","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Now with the same initial data, order being setted to 6, and varepsilon = 019 0019 ldots 19times 10^-8.\nHere floats are coded on 256 bits.","category":"page"},{"location":"quickstart/#Precision-of-the-result-with-order-6-2","page":"Quickstart","title":"Precision of the result with order 6","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"(Image: )","category":"page"},{"location":"future_work/#Future-work","page":"Future work","title":"Future work","text":"","category":"section"},{"location":"future_work/","page":"Future work","title":"Future work","text":"precision on parameter.\nexponential runge-kutta method","category":"page"},{"location":"future_work/#The-\"classical\"-Runge-Kutta-method-(order-4)-adapted-to-the-exponential-(not-yet-implemented)","page":"Future work","title":"The \"classical\" Runge-Kutta method (order 4) adapted to the exponential (not yet implemented)","text":"","category":"section"},{"location":"future_work/","page":"Future work","title":"Future work","text":"Notations : ","category":"page"},{"location":"future_work/","page":"Future work","title":"Future work","text":"We denote by G the function which transforms hatU to hatf, so G(hatU) = hatf.\nWe denote by S_t_0^t_1(t_2ell) the intégral S_t_0^t_1(t_2ell) = int_t_0^t_1 e^- i ell (t_2 - s)varepsilon ds = ( i varepsilon  ell) ( e^- i ell (t_2 - t_1)varepsilon-e^- i ell (t_2 - t_0)varepsilon)","category":"page"},{"location":"future_work/","page":"Future work","title":"Future work","text":"Here are the calculations","category":"page"},{"location":"future_work/","page":"Future work","title":"Future work","text":"u_1ell = hatU_n ell\nu_2ell = e^- i ell h_n (2 varepsilon)hatU_n ell + S_0^h_n 2 ( h_n 2ell ) G_ell(u_1)\nu_3ell = e^- i ell h_n (2 varepsilon)hatU_n ell + S_0^h_n 2 ( h_n 2ell )  G_ell(u_2)\nu_4ell = e^- i ell h_n (2varepsilon)u_2ell + S_0^h_n2 ( h_n2ell ) 2 G_ell(u_3)-G_ell(u_1) (see (28) of S.M. Cox, P.C. Matthews (2002), with c=-i ell h_n varepsilon)   ","category":"page"},{"location":"future_work/","page":"Future work","title":"Future work","text":"From (29) of S.M. Cox, P.C. Matthews (2002), with c=-i ell h_n varepsilon, we have","category":"page"},{"location":"future_work/","page":"Future work","title":"Future work","text":"hatU_n+1 ell = e^- i ell h_n varepsilonhatU_n ell +  G_ell(u_1) -4+i ell h_n varepsilon + e^-i ell h_n varepsilon(4+3i ell h_n varepsilon+(i ell h_n varepsilon)^2+ (2 G_ell(u_2) + G_ell(u_3) )-2-i ell h_n varepsilon+e^-i ell h_n varepsilon(2-i ell h_n varepsilon) + G_ell(u_4)-4+3i ell h_n varepsilon -(i ell h_n varepsilon)^2 + e^-i ell h_n varepsilon(4+i ell h_n varepsilon)(h_n^2 (i ell h_n varepsilon)^3)","category":"page"},{"location":"numerical_method/#Numerical-method","page":"Numerical Method","title":"Numerical method","text":"","category":"section"},{"location":"numerical_method/#Two-scale-formulation","page":"Numerical Method","title":"Two-scale formulation","text":"","category":"section"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"First, rewrite equation (1) using the variable change w(t)=exp(-(t-t_start)Avarepsilon) u(t) to obtain","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"fracd w(t)dt = FBig(fract-t_startvarepsilon w(t) Big)  w(t_start)=u_in  varepsilonin 0 1","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"where the function F is expressed from the data of the original problem (1)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"FBig( fracsvarepsilon w Big) = exp(-sAvarepsilon)  f( exp(sAvarepsilon)  w)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"We then introduce the function U(t tau) tauin 0 2 pi such that U(t tau=(t-t_start)varepsilon) = w(t). The two-scale function is then the solution of the following equation","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"fracpartial Upartial t + frac1varepsilon fracpartial Upartial tau =  F( tau U)  U(t=t_start tau)=Phi(tau)  varepsilonin 0 1  (2)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"where Phi is a function checking Phi(tau=0)=u_0 chosen so that the U solution of (2) is smooth (see Philippe Chartier, Nicolas Crouseilles, Mohammed Lemou, Florian Méhats (2015) and Philippe Chartier, Mohammed Lemou, Florian Méhats, Xiaofei Zhao (2020).","category":"page"},{"location":"numerical_method/#Discretization","page":"Numerical Method","title":"Discretization","text":"","category":"section"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"The numerical method is based on a discretization of equation (2). In the direction tau, a spectral method is used, while for the time t, an exponential Adams-Bashforth method allows to build a high order method (see Philippe Chartier, Mohammed Lemou, Florian Méhats, Xiaofei Zhao (2020)). The initialization is based on a \"butterfly\" technique (going back and forth around the initial time).","category":"page"},{"location":"numerical_method/#Initialization","page":"Numerical Method","title":"Initialization","text":"","category":"section"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"Let r be the order of the method AB_r.\nLet Delta t the time step, for i in r -(r-1) ldots r-1 r, we note u_i = u(t_start+i Delta t).\nLet r be the orders of the intermediate AB methods we will use.\nIf u_k is known with a precision of mathcal O(Delta t^r+1), and for r geq 2 u_k-1 ldots u_k-r+1 are known with a precision of mathcal O(Delta t^r) then we can calculate u_k+1 with a precision of mathcal O(Delta t^r+1) with the method AB_r.\nSimilarly, if u_k is known with a precision of mathcal O(Delta t^r+1), and for r geq 2 u_k+1 ldots u_k+r-1 are known with a precision of mathcal O(Delta t^r) then we can calculate u_k-1 with a precision of mathcal O(Delta t^r+1) with the method AB_r.","category":"page"},{"location":"numerical_method/#Algorithm","page":"Numerical Method","title":"Algorithm","text":"","category":"section"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"With the method AB_1, from u_0 we calculate u_-1 with a precision of mathcal O(Delta t^2)\nWith the method AB_2, starting from u_0 and u_-1, we calculate u_1 with a precision of mathcal O(Delta t^3)\nFor r = 3 to r = r.\nFor k=1 to k=r-1\nWith the method AB_r-1, from u_1-k u_2-k ldotsu_r-1-k, we calculate u_-k with a precision of mathcal O(Delta t^r)\nFor k=1 to k=r-1\nWith the method AB_r, from u_k-1 u_k-2 ldotsu_k-r, we calculate u_k with a precision of mathcal O(Delta t^r+1)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"At the end of this algorithm, the values u_0 u_1 ldots u_r-1 are known with a precision of mathcal O(Delta t^r+1), we can launch the algorithm AB_r. Note that this technique requires that the function f has to be smooth enough (namely fin mathcal C^r(t_start - r Delta t t_end)).  ","category":"page"},{"location":"numerical_method/#The-Adams-Bashforth-Method","page":"Numerical Method","title":"The Adams-Bashforth Method","text":"","category":"section"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"For an Adams-Bashforth method of order r in time and spectral tau, we first introduce a mesh in the tau direction.\ntau_ell = ell Delta tau ell = 0 ldots N_tau-1. Where N_tau is the number of points of discretization. If we apply the Fourier transform to the two-scale equation, we obtain ","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"fracpartial hatU_ellpartial t + fraciellvarepsilonhatU_ell = hatF_ell(t)  ell=-N_tau2 dots N_tau2-1","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"with","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"U(t tau_k) = sum_ell=-N_tau2^N_tau2-1 hatU_ell(t) e^iell k 2piN_tau  text and  F(tau_k U(t tau_k)) = sum_ell=-N_tau2^N_tau2-1 hatF_ell(t) e^iell k 2piN_tau","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"and the inverse (discrete) Fourier transform formulae","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"hatU_ell(t) = frac1N_tausum_k=0^N_tau-1 U(t tau_k) e^-iell k 2piN_tau text and  hatF_ell(t) = frac1N_tausum_k=0^N_tau-1 F(tau_k U(t tau_k))e^-iell k 2piN_tau","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"If we wish to calculate hatF_ell from hatU_ell we have the following formula ","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"F(tau_kU(t tau_k)) = e^-tau_k Af(e^tau_k AU(t tau_k)) ","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"from which the Fourier transform is calculated in tau from the discrete Fourier transform formulas above.","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"Now, given a time step Delta t0 and a discretization in time t_n=nDelta t, we can write the following Duhamel formula (ngeq 0)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"hatU_ell(t_n+1) \n= e^-iellDelta tvarepsilonhatU_ell(t_n)  + int_0^Delta t e^-iell(Delta t -s)varepsilon hatF_ell(t_n+s)ds","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"Thus, to obtain a (r+1) scheme, we can  approaches the function hatF_ell(t_n+s) by the Lagrange polynomial of order r interpolator at points t_n-j j=0 dots r. This polynomial is written ","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"hatF_ell(t_n+s) approx sum_k=0^r Big(Pi_j=0 jneq k^r fracs+j Delta t(j-k)Delta t Big) hatF_ell(t_n-t_j)  ngeq 0","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"Thus, from this approximation, we integrate exactly, which requires the following formulas","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"p^r_ell j = int_0^Delta te^-iell(Delta t -s)varepsilonBig( Pi_j=0 jneq k^r fracs+j Delta t(j-k)Delta tBig) ds","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"for each j and ell such that 0leq jleq r  ell=-N_tau2 dots N_tau2-1. These coefficients p^r_ell j can be pre-calculated and stored once and for all. Thus, the schema is finally written","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"hatU_ell^n+1= e^-iellDelta tvarepsilonhatU_ell^n + sum_j=0^r p^r_ell j hatF_ell^n-j","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"with hatU_ell^n approx hatU_ell(t_n) and hatF_ell^n-japprox hatF_ell(t_n-j). ","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"We can verify that the truncation error in this schema is  mathcal O(Delta t^r+1), once the initial values  hatU_ell^1 dots hatU_ell^r have been calculated.  ","category":"page"},{"location":"numerical_method/#Non-homogeneous-case-f(t,-u)","page":"Numerical Method","title":"Non-homogeneous case f(t u)","text":"","category":"section"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"Here we consider the case where f depends on the variable t.","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"fracd u(t)dt = frac1varepsilon A u(t) + f(t u(t))  u(t=t_start)=u_in  varepsilonin 0 1  (3)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"The non-homogeneous case (3) falls under (1), by entering the variable  theta  t in t_start t_end mapsto theta(t) = tin mathbbR  which allows us to reformulate the non-homogeneous case (3) into a homogeneous problem of the form (1). Indeed, we rephrase (3) as follows","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"beginaligned\nfracd u(t) dt   = frac1varepsilon Au(t) + f(theta(t) u(t)) \nfracd theta(t) dt   = 1\nendaligned(4)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"with the initial condition  u(t_start)=u_in theta(t_start)=t_start. Thus, the problem (4) is rewritten into an equation\nsatisfied by y tin t_start t_end mapsto y(t) =(u(t) theta(t))in mathbbR^n+1","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"fracd ydt = frac1varepsilon tildeA y + g(y)  y(t_start)=(u_in t_start)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"with tildeAinmathcal M_n+1 n+1(mathbbR)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"tildeA=\nleft(\nbeginarraycccc\n             0 \n    A       0 \n            0 \n0  0  0   0 \nendarray\nright)  text and  \ng(y)=g(u theta) = left(\nbeginarraycccccc\nf(theta u) \n1\nendarray\nright) in mathbbR^n+1","category":"page"},{"location":"#HOODESolver.jl","page":"Documentation","title":"HOODESolver.jl","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"The objective of this Julia package is to valorize the recent developments carried out within INRIA team MINGuS on Uniformly Accurate numerical methods (UA) for highly oscillating problems. We propose to solve the following equation ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"fracd u(t)dt = frac1varepsilon A u(t) + f(t u(t)) qquad u(t=t_start)=u_in qquad varepsilonin 0 1 qquad (1)","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"with ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"u  tin t_start t_end mapsto u(t)in mathbbR^n quad t_start t_endin mathbbR, \nu_inin mathbbR^n, \nAin mathcalM_nn(mathbbR) is such that tau mapsto exp(tau A) is 2 pi-periodic,  \nf  (t u) in  mathbbRtimes mathbbR^n mapsto mathbbR^n.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"The purpose here is to write an explanatory documentation of the Julia package containing the two-scale method (see Philippe Chartier, Mohammed Lemou, Florian Méhats, Xiaofei Zhao (2020), Philippe Chartier, Nicolas Crouseilles, Mohammed Lemou, Florian Méhats (2015) and Nicolas Crouseilles, Mohammed Lemou, Florian Méhats (2013). This package is inspired by the Differential Equations package SciML.","category":"page"},{"location":"#References","page":"Documentation","title":"References","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"#Index","page":"Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Modules = [HOODESolver]\nOrder   = [:type]","category":"page"},{"location":"types/#HOODESolver.HOODEAB","page":"Types","title":"HOODESolver.HOODEAB","text":"HOODEAB( order=4, ntau=32)\n\nAlgorithm for High-Oscillatory equation\n\n\n\n\n\n","category":"type"},{"location":"types/#HOODESolver.HOODEProblem","page":"Types","title":"HOODESolver.HOODEProblem","text":"HOODEProblem(f, u0, tspan, p, A, epsilon, B)\n\nThe HOODE problem is :\n\nfracdudt = ( frac1epsilon A + B)  u + f(upt)\n\nThe initial condition is u(tspan1) = u0.\nThe solution u(t) will be computed for tspan1  t  tspan2\nConstant parameters to be supplied as the second argument of f.\nPeriodic Matrix of the problem.\nepsilon of the problem.\nMatrix of linear problem to get the exact solution\n\n\n\n\n\n","category":"type"},{"location":"types/#HOODESolver.PolyExp","page":"Types","title":"HOODESolver.PolyExp","text":"PolyExp(p::Vector{T}, a::T, b::T)\nPolyExp(pol::Polynomial{T},a::T,b::T)\n\nOn the model of Polynomial from package Polynomials, construct a function that is a polynome multiply by an exponential function. The exponential is an exponential of an affine function a x + b. The polynome is construct from its coefficients p, lowest order first.\n\nIf f = (p_n x^n + ldots + p_2 x^2 + p_1 x + p_0)e^a x + b, we construct this through PolyExp([p_0, p_1, ..., p_n], a, b).  It is also possible to construct it directly from the polynome.\n\nIn the sequels some methods with the same name than for Polynomial are implemented (derivative, integrate, strings, ...) but not all, only the methods needed are developped.\n\nArguments :\n\np::Vector{T} or pol::Polynomial{T} : vector of coefficients of the polynome, or directly the polynome.\na::T, b::T : coefficients of affine exponentiated function.\n\nExamples\n\njulia> pe=PolyExp([1,2,3],2,1)\nPolyExp(Polynomial(1 + 2*x + 3*x^2)*exp(2*x + 1))\n\njulia> pe(0)\n2.718281828459045\n\njulia> pe(1)\n120.51322153912601\n\n\n\n\n\n","category":"type"},{"location":"types/#HOODESolver.PrepareFftBig","page":"Types","title":"HOODESolver.PrepareFftBig","text":"PrepareFftBig( size_fft::Unsigned, [T=BigFloat])\n\nImmutable structure to operate fft transform,  x is the type of non transformed data also called signal.\n\nArguments :\n\nsize_fft::Integer : Number of values, must be a power of two\n[T=BigFloat | x::T ] : type of the values\n\nImplementation\n\nsize_fft : size of the signal\ntab_permut : permutation\nroot_one : size order roots of one\nrootoneconj : conjugate of root_one\n\n\n\n\n\n","category":"type"},{"location":"types/#HOODESolver.PreparePhi","page":"Types","title":"HOODESolver.PreparePhi","text":"PreparePhi(n_tau::Integer, epsilon::AbstractFloat, matrix_A::Matrix{Number},\nfct::Function, [matrix_B::Matrix])\n\nImmutable structure, to share calculations, needed for the phi function. These data can be used elsewhere for example in twoscale function.\n\nArguments :\n\nn_tau::Integer : number of value around the unit disk, it must be a power of two.\nepsilon::AbstractFloat : epsilon of the system, the type of this value will be the typeof the result.\nmatrix_A::Matrix{Number} : Matrix of twoscale system\nfct::Function : function of the system\n[matrix_B::Matrix] : matrix representing the linear function for debug\n\nKeywords\n\nmode=1 : possibility of addionnal modes for optional behavior\nparamfct=missing : middle parameter of function fct\nt_0=zero(epsilon) : beginning of the time\n\nFields :\n\nepsilon : epsilon of the system.\nn_tau : number of values for fft\ntau_list : list of values around the unit disk (0 ... ntau/2 -ntau/2-1 ... -1 )\ntau_int : list of values to integrate FFT\nmatrix_Ap : sparse matrix with time dimension\ntau_Ap : for each angular tau around the unit disk the matrix e^(tau time Ap)\ntau_Ap_inv : inverse of tau_Ap\npar_fft : fft parameters\nfct : function of differential equation\nparamfct : middle parameter of function fct\nsize_vect : size of vector that is the size of the matrix\nmatrix_B : B matrix for the linear case\nmode : for optional behavior\nt_0 : beginning of the time\n\n\n\n\n\n","category":"type"},{"location":"types/#HOODESolver.PrepareTwoScalesPureAB","page":"Types","title":"HOODESolver.PrepareTwoScalesPureAB","text":"PrepareTwoScalesPureAB(nb_t, t_max, order, par_u0::PrepareU0)\n\nImmutable structure, to share calculations, needed for the twoscale function\n\nArguments :\n\nnb_t::Int : number of time slices\nt_max: end of the time\norder : order for compute the coefficients\npar_u0::PrepareU0 : prepared initial data\n\nKeywords :\n\np_coef::Union{CoefExpAB,Missing}=missing : precomputed coefficients of AB method \nverbose=100 : trace level\n\nFields :\n\nnb_t : number of time slices\nt_max : end of the time\norder : order for compute the coefficients\nparphi : prepared parameters for phi (from par_u0)\npar_u0 : prepared initial data\np_coef : computed coefficients\nexptau : exp( -imdt'\tau'/epsilon) for all '\tau' values\nexptau_inv : inverse of exptau\nverbose : trace level\n\n\n\n\n\n","category":"type"},{"location":"types/#HOODESolver.PrepareU0","page":"Types","title":"HOODESolver.PrepareU0","text":"PrepareU0(parphi::PreparePhi, order, u0, newprec)\n\nPreparation of the original data\n\nArguments\n\nparphi::PreparePhi : phi prepared parameters\norder : order of the preparation\nu0 : initial data\n[newprec] : precision for the compute, if no given a default value is computed as a function of epsilon\n\nFields\n\nparphi : phi prepared parameters\norder : order of the preparation\nut0 : formated initial data\nu0 :initial data\n\n\n\n\n\n","category":"type"}]
}
